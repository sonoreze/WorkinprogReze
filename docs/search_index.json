[["index.html", "Sonorezé Chapitre 1 Présentation", " Sonorezé Tristan Lorino 2022-05-13 Chapitre 1 Présentation Dans RStudio, on installe le package bookdown, puis on créé un nouveau projet avec l’option New Directory et le modèle Book Project Using Bookdown. On appelle WorkinprogReze ce projet ; c’est également le nom du dossier qui est créé en local (et ce sera également le nom du repository GitHub). Ce dossier contient : des fichiers d’extension Rmd (RMarkdown) pour les pages html à générer, dont le fichier index.Rmd qui servira de point de départ pour le site web GitHub ; chaque fichier Rmd contient un et un seul chapitre, lequel est défini par la balise # ; un fichier WorkinprogReze.Rproj relatif au projet RStudio ; un fichier _bookdown.yml qui configure la compilation en entrée ; un fichier _output.yml qui configure la compilation en sortie et le rendu ; un dossier _book qui contient les pages html générées à partir des fichiers rmd. Attention : la compilation par le bouton Knit de RStudio peut faillir dans le rendu du bookdown. Il est alors indispensable de saisir dans la console : bookdown::render_book() Il arrive parfois que la compilation de index.Rmd retourne des messages d’erreur : il peut être utile, dans ce cas de vider le cache de knitr (via le menu déroulant à droite du bouton Knit). Référence Bookdown : https://bookdown.org/yihui/bookdown/ Référence Sonorezé : https://github.com/sonoreze/WorkinprogReze "],["configuration.html", "Chapitre 2 Configuration 2.1 Configuration de knitr 2.2 Déploiement sur GitHub Pages", " Chapitre 2 Configuration 2.1 Configuration de knitr Pour afficher par défaut les morceaux de code R (chunks) : knitr::opts_chunk$set(echo = TRUE) Pour que knitr retrouve tous ses petits dans l’arborescence du dossier WorkinprogReze.Rproj : knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file()) Par défaut on utilise le cache de knitr, ce qui est censé accélérer la compilation : knitr::opts_chunk$set(cache =FALSE) Pour la typo française, on précise que les décimales seront séparées des entiers par une virgule : options(OutDec=&quot;,&quot;) Attention à cette dernière option : elle peut causer des désagréments aux légendes générées avec le package leaflet. Pour les sorties francisées (par exemple les noms des mois) : Sys.setlocale(&quot;LC_CTYPE&quot;,&quot;fr_FR.UTF-8&quot;) 2.2 Déploiement sur GitHub Pages GitHub Pages va puiser les pages html dans un dossier nommé /docs. Aussi commence-t-on par créer un tel dossier dans le dossier WorkinprogReze. Pour déployer le bookdown sur GitHub, on doit transférer de manière automatique les pages html générées par knitr et stockées dans _book, vers le nouveau dossier /docs. Pour ce faire, on ajoute au fichier _bookdown.yml la commande : output_dir: &quot;docs&quot; "],["packages.html", "Chapitre 3 Packages", " Chapitre 3 Packages Le package pacman permet de gérer l’installation préalable, puis le chargement de packages. Voici ceux qui sont utilisés : if (!require(&quot;pacman&quot;)) install.packages(&quot;pacman&quot;) library(pacman) pacman::p_load(here,ggplot2,ggforce,ggthemes,thematic,plotly,scales,tidyr,dplyr,lubridate,stringr,forcats,rgdal,sp,sf, rgeos,geoR,gstat,spacetime,devtools,leaflet,leaflet.extras,jsonlite,mapview,RColorBrewer, viridis,flexdashboard,fontawesome,rprojroot) here : permet une gestion relative de l’arborescence des fichiers ; ggplot2, ggforce, ggthemes, thematic, plotly : gestion des graphiques ; scales : gestion du format des nombres ; tidyr, dplyr : gestion des données ; lubridate : gestion des dates ; forcats : gestion des variables factorielles ; jsonlite, rgdal, sp, sf, geoR, gstat, spacetime : gestion des données spatiales ; leaflet,leaflet.extras, mapview : gestion des représentations spatiales ; RColorBrewer,viridis : gestion des couleurs ; flexdashboard : gestion du tableau de bord html ; fontawesome : accès aux fontes web ; rprojroot : gestion des fichiers de projet R. "],["données.html", "Chapitre 4 Données 4.1 Identifiant de trace 4.2 Longueur des traces", " Chapitre 4 Données 4.1 Identifiant de trace On créé un dossier /R à la racine de WorkinprogReze, dans lequel on stockera les scripts R. On y place dedans le fichier Statistiques.R qui va créer de nombreux tableaux de données à partir des données brutes. On charge les données issues de metabase qui sont contenues dans le fichier noisecapture_data.Rda, puis on compile en entrée deux scripts : Statistiques.R pour la génération de tableaux de données et de statistiques, et Color.R pour la définition d’une palette de couleurs créée par https://www.coloringnoise.com/theoretical_background/new-color-scheme/ load(here(&quot;noisecapture_data.Rda&quot;)) source(here(&quot;R&quot;,&quot;Statistiques.R&quot;)) source(here(&quot;R&quot;,&quot;Color.R&quot;)) On va créer, à partir de l’identifiant Id des utilisateurs, les variables suivantes : IdTraceReset : c’est un identifiant de trace par utilisateur, qui s’incrémente dès que le temps passé entre deux enregistrements excède 1 s ; IdGlobal qui concatène Id et IdTraceReset, de manière à avoir un identifiant unique par trace (via stringr::str_c); IdTrace, reformulation de l’identifiant de trace sous forme d’identifiant numérique unique (via dplyr::cur_group_id). noisecapture_data &lt;- as.data.frame(noisecapture_data) tags_table_init &lt;- as.data.frame(noisecapture_data[,c(&quot;Id&quot;,&quot;Date&quot;,&quot;x&quot;,&quot;y&quot;,&quot;leq_mean&quot;,&quot;tags&quot;,&quot;accuracy&quot;)]) %&gt;% arrange(Id,Date) %&gt;% group_by(Id) %&gt;% arrange(Date) %&gt;% mutate(IdTraceReset=cumsum(c(TRUE, as.integer(diff(as.POSIXct(Date)), units = &quot;secs&quot;) &gt;= 2L))) %&gt;% ungroup() %&gt;% mutate(IdGlobal=str_c(Id,IdTraceReset)) %&gt;% arrange(IdGlobal) %&gt;% group_by(Id) %&gt;% arrange(IdTraceReset) %&gt;% group_by(IdGlobal) %&gt;% mutate(IdTrace=cur_group_id()) %&gt;% ungroup() On supprime ensuite les traces : sans tag ; dont les coordonnées gps sont manquantes ; tags_table &lt;- tags_table_init %&gt;% filter(tags != &quot;&quot;) %&gt;% filter(x != &quot;NA&quot;) %&gt;% filter(accuracy&lt;20) %&gt;% select(-c(accuracy,IdGlobal,IdTraceReset)) 4.2 Longueur des traces Afin que le tag ait un sens, on va supprimer les traces dont la longueur excède 500 m. Pour ce faire, on calcule les distances entre les points géolocalisés consécutifs pris deux à deux (pour chaque trace), puis on calcule la somme des distances par trace, et enfin on ne sélectionne que les traces dont la distance totale est inférieure à 500 m : tags_table &lt;- tags_table %&gt;% st_as_sf(coords = c(&quot;x&quot;,&quot;y&quot;),remove = F) %&gt;% st_set_crs(4326) %&gt;% group_by(IdTrace) %&gt;% mutate( lead = geometry[row_number() + 1], distance = st_distance(geometry, lead, by_element = T), ) %&gt;% mutate(DistanceTotale = sum(as.numeric(distance),na.rm=TRUE)) %&gt;% select(-c(lead)) %&gt;% filter(DistanceTotale&lt;500) On passe de 1104 traces initialement à 639, soit une conservation de 57,88 % des traces. "],["procédure.html", "Chapitre 5 Procédure", " Chapitre 5 Procédure La procédure consiste à : créer un identifiant par trace (suite d’enregistrements successifs) ; ne garder qu’un enregistrement par trace ; supprimer les traces qui n’ont pas été taggées, ainsi que celles sans coordonnées GPS : tags_table[1:10,] ## Simple feature collection with 10 features and 9 fields ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: -1,561308 ymin: 47,19118 xmax: -1,561303 ymax: 47,19121 ## Geodetic CRS: WGS 84 ## # A tibble: 10 × 10 ## # Groups: IdTrace [1] ## Id Date x y leq_mean tags IdTrace geometry distance DistanceTotale ## &lt;chr&gt; &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;POINT [°]&gt; [m] &lt;dbl&gt; ## 1 029d 2021-12-06 22:54:28 -1.56 47.2 42.0 indoor 1 (-1,561303 47,19119) 0.427 22.2 ## 2 029d 2021-12-06 22:54:29 -1.56 47.2 41.2 indoor 1 (-1,561305 47,19118) 0.359 22.2 ## 3 029d 2021-12-06 22:54:30 -1.56 47.2 40.8 indoor 1 (-1,561305 47,19118) 0.0654 22.2 ## 4 029d 2021-12-06 22:54:31 -1.56 47.2 45.7 indoor 1 (-1,561305 47,19118) 1.52 22.2 ## 5 029d 2021-12-06 22:54:46 -1.56 47.2 40.8 indoor 1 (-1,561307 47,19119) 1.15 22.2 ## 6 029d 2021-12-06 22:54:47 -1.56 47.2 40.8 indoor 1 (-1,561307 47,1912) 0.0813 22.2 ## 7 029d 2021-12-06 22:54:48 -1.56 47.2 40.8 indoor 1 (-1,561307 47,1912) 0.0846 22.2 ## 8 029d 2021-12-06 22:54:49 -1.56 47.2 40.8 indoor 1 (-1,561307 47,1912) 0.00717 22.2 ## 9 029d 2021-12-06 22:54:50 -1.56 47.2 40.9 indoor 1 (-1,561307 47,1912) 0.775 22.2 ## 10 029d 2021-12-06 22:54:51 -1.56 47.2 40.8 indoor 1 (-1,561308 47,19121) 0.0917 22.2 à partir de la colonne « tags », qui contient pour chaque trace (chaque ligne) un ou plusieurs tags séparés par des virgules : créer une nouvelle colonne « tags » avec un seul tag (par ligne), quitte à dupliquer une trace (une ligne) lorsque cette-dernière a plusieurs tags : tags_table &lt;- tags_table %&gt;% transform(tags = strsplit(as.character(tags),&quot;,&quot;)) %&gt;% unnest(tags) %&gt;% mutate(TagGroup = case_when(tags == &quot;indoor&quot; | tags == &quot;test&quot; ~ &quot;Condition&quot;, tags == &quot;wind&quot; | tags == &quot;rain&quot; ~ &quot;Meteo&quot;, tags == &quot;marine_traffic&quot; | tags == &quot;air_traffic&quot; | tags == &quot;rail&quot; | tags == &quot;road&quot; ~ &quot;Trafic&quot;, TRUE ~ &quot;Ambiance&quot;)) Voici les effectifs par tags : summary(as.factor(tags_table$tags)) ## air_traffic alarms animals chatting children footsteps indoor industrial marine_traffic music rail rain ## 23458 1757 43952 18553 12438 26195 16303 470 83 6288 5032 10930 ## road test vegetation water wind works ## 74416 1126 15980 1232 17409 8826 Quatre catégories ont été définies : Météo : rain / wind Condition : indoor / test Trafic : road / marine_traffic / air_traffic / rail Ambiance : chatting / footsteps / water / animals / vegetation / works / children / music / alarms / industrial Voici les effectifs par catégorie : ggplot(tags_table, aes(x=TagGroup)) + geom_histogram(stat=&quot;count&quot;) Data_numerique &lt;- tags_table[,c(&quot;x&quot;,&quot;y&quot;,&quot;TagGroup&quot;)] pal &lt;- colorFactor(viridis(7), Data_numerique$TagGroup) leaflet(Data_numerique) %&gt;% addProviderTiles(&quot;CartoDB.Positron&quot;) %&gt;% addCircleMarkers(lng = ~x, lat = ~y, radius = 1.5, color = pal(Data_numerique$TagGroup), stroke=FALSE, fillOpacity = 0.8, popup = ~TagGroup) %&gt;% addLegend(&quot;bottomleft&quot;, pal = pal, values = Data_numerique$TagGroup, na.label = &quot;NA&quot;, title = &quot;Catégories&quot;, #labels = pal2, opacity = .8, ) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
