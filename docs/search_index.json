[["index.html", "Sonorezé Chapitre 1 Présentation", " Sonorezé Tristan Lorino 2022-05-11 Chapitre 1 Présentation Dans RStudio, on installe le package bookdown, puis on créé un nouveau projet avec l’option New Directory et le modèle Book Project Using Bookdown. On appelle WorkinprogReze ce projet ; c’est également le nom du dossier qui est créé en local (et ce sera également le nom du repository GitHub). Ce dossier contient : des fichiers d’extension Rmd (RMarkdown) pour les pages html à générer, dont le fichier index.Rmd qui servira de point de départ pour le site web GitHub ; chaque fichier Rmd contient un et un seul chapitre, lequel est défini par la balise # ; un fichier WorkinprogReze.Rproj relatif au projet RStudio ; un fichier _bookdown.yml qui configure la compilation en entrée ; un fichier _output.yml qui configure la compilation en sortie et le rendu ; un dossier _book qui contient les pages html générées à partir des fichiers rmd. Attention : la compilation par le bouton Knit de RStudio peut faillir dans le rendu du bookdown. Il est alors indispensable de saisir dans la console : bookdown::render_book() Référence Bookdown : https://bookdown.org/yihui/bookdown/ Référence Sonorezé : https://github.com/sonoreze/WorkinprogReze "],["configuration.html", "Chapitre 2 Configuration 2.1 Configuration de knitr 2.2 Déploiement sur GitHub Pages", " Chapitre 2 Configuration 2.1 Configuration de knitr Pour afficher par défaut les morceaux de code R (chunks) : knitr::opts_chunk$set(echo = TRUE) Pour que knitr retrouve tous ses petits dans l’arborescence du dossier WorkinprogReze.Rproj : knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file()) Par défaut on utilise le cache de knitr, ce qui est censé accélérer la compilation : knitr::opts_chunk$set(cache =FALSE) Pour la typo française, on précise que les décimales seront séparées des entiers par une virgule : options(OutDec=&quot;,&quot;) Attention à cette dernière option : elle peut causer des désagréments aux légendes générées avec le package **leaflet**. Pour les sorties francisées (par exemple les noms des mois) : Sys.setlocale(&quot;LC_CTYPE&quot;,&quot;fr_FR.UTF-8&quot;) 2.2 Déploiement sur GitHub Pages GitHub Pages va puiser les pages html dans un dossier nommé /docs. Aussi commence-t-on par créer un tel dossier dans le dossier WorkinprogReze. Pour déployer le bookdown sur GitHub, on doit transférer de manière automatique les pages html générées par knitr et stockées dans _book, vers le nouveau dossier /docs. Pour ce faire, on ajoute au fichier _bookdown.yml la commande : output_dir: &quot;docs&quot; "],["packages.html", "Chapitre 3 Packages", " Chapitre 3 Packages Le package pacman permet de gérer l’installation préalable, puis le chargement de packages. Voici ceux qui sont utilisés : if (!require(&quot;pacman&quot;)) install.packages(&quot;pacman&quot;) ## Le chargement a nécessité le package : pacman library(pacman) pacman::p_load(here,ggplot2,ggforce,ggthemes,thematic,plotly,scales,tidyr,dplyr,lubridate,stringr,forcats,rgdal,sp,sf, rgeos,geoR,gstat,spacetime,devtools,leaflet,leaflet.extras,jsonlite,mapview,RColorBrewer, viridis,flexdashboard,fontawesome,rprojroot) ## &#39;RandomFields&#39; will NOT use OMP here : permet une gestion relative de l’arborescence des fichiers ; ggplot2, ggforce, ggthemes, thematic, plotly : gestion des graphiques ; scales : gestion du format des nombres ; tidyr, dplyr : gestion des données ; lubridate : gestion des dates ; forcats : gestion des variables factorielles ; jsonlite, rgdal, sp, sf, geoR, gstat, spacetime : gestion des données spatiales ; leaflet,leaflet.extras, mapview : gestion des représentations spatiales ; RColorBrewer,viridis : gestion des couleurs ; flexdashboard : gestion du tableau de bord html ; fontawesome : accès aux fontes web ; rprojroot : gestion des fichiers de projet R. "],["données.html", "Chapitre 4 Données 4.1 Un identifiant de trace 4.2 Question en suspens", " Chapitre 4 Données 4.1 Un identifiant de trace On créé un dossier /R à la racine de WorkinprogReze, dans lequel on stockera les scripts R. On y place dedans le fichier Statistiques.R qui va créer de nombreux tableaux de données à partir des données brutes. On charge les données issues de metabase et on compile en entrée le script Statistiques.R : load(here(&quot;noisecapture_data.Rda&quot;)) source(here(&quot;R&quot;,&quot;Statistiques.R&quot;)) On va créer, à partir de l’identifiant Id des utilisateurs, les variables suivantes : IdTraceReset : c’est un identifiant de trace par utilisateur, qui s’incrémente dès que le temps passé entre deux enregistrements excède 1 s ; IdGlobal qui concatène Id et IdTraceReset, de manière à avoir un identifiant unique par trace (via stringr::str_c); IdTrace, reformulation de l’identifiant de trace sous forme d’identifiant numérique unique (via dplyr::cur_group_id). noisecapture_data &lt;- as.data.frame(noisecapture_data) trace_table &lt;- as.data.frame(noisecapture_data[,c(&quot;Id&quot;,&quot;Date&quot;,&quot;x&quot;,&quot;y&quot;,&quot;leq_mean&quot;,&quot;tags&quot;)]) %&gt;% arrange(Id,Date) %&gt;% group_by(Id) %&gt;% arrange(Date) %&gt;% mutate(IdTraceReset=cumsum(c(TRUE, as.integer(diff(as.POSIXct(Date)), units = &quot;secs&quot;) &gt;= 2L))) %&gt;% ungroup() %&gt;% mutate(IdGlobal=str_c(Id,IdTraceReset)) %&gt;% arrange(IdGlobal) %&gt;% group_by(Id) %&gt;% arrange(IdTraceReset) %&gt;% group_by(IdGlobal) %&gt;% mutate(IdTrace=cur_group_id()) %&gt;% ungroup() %&gt;% distinct(IdTrace, .keep_all = TRUE) On supprime ensuite les traces : sans tag ; dont les coordonnées gps sont manquantes ; tags_table &lt;- trace_table %&gt;% filter(tags != &quot;&quot;) %&gt;% filter(x != &quot;NA&quot;) %&gt;% select(-c(IdGlobal,IdTraceReset)) 4.2 Question en suspens Comment déterminer qu’une trace fait plus de 500 m ? En calculant les distances entre les points pris deux à deux, puis en sommant ces distances. Le package {sf} fournit la fonction st_distance pour le calcul d’une matrice de distances, et st_length pour le calcul de la distance rectiligne entre deux points. Soient deux points de la piste de glissance, séparés (d’après Google Maps, cf. figure ci-après) par une distance de 898,18 m. Je ne comprends pas pourquoi le résultat retourné par les fonctions de {sf} diffèrent du calcul de Google Maps. coo &lt;- matrix(c( 47.155448754072374, -1.6406400682309141, 47.15744374926704, -1.652151433982812 ), ncol=2, byrow=T) coo_col &lt;- data.frame(coo) dimnames(coo_col)[[2]] &lt;- c(&quot;latitude&quot;,&quot;longitude&quot;) coord_col &lt;- SpatialPointsDataFrame(coords=coo_col[,1:2], data=as.data.frame(coo_col)) coord_col_sf &lt;- st_as_sf(coord_col, crs = 4326, agr = &quot;constant&quot;, remove = F) st_crs(coord_col_sf) &lt;- 4326 #EPSG WGS84 # Calcul de la distance entre les deux points my_coords_sf &lt;- st_as_sf(coo_col, coords = c(&quot;latitude&quot;,&quot;longitude&quot;), crs = 4326) st_distance(coord_col_sf) ## Units: [m] ## [,1] [,2] ## [1,] 0,000 1299,072 ## [2,] 1299,072 0,000 # Même résultat avec la fonction ci-dessous (attention : elle # n&#39;aime pas les noms de colonnes, c&#39;est pourquoi le jeu de données est coo # et pas coo_col) line = st_sfc(st_linestring(coo), crs = 4326) st_length(line) ## 1299,072 [m] Piste de glissance. "],["procédure.html", "Chapitre 5 Procédure", " Chapitre 5 Procédure La procédure consiste à : créer un identifiant par trace (suite d’enregistrements successifs) ; ne garder qu’un enregistrement par trace ; supprimer les traces qui n’ont pas été taggées, ainsi que celles sans coordonnées GPS : tags_table[1:10,] ## # A tibble: 10 × 7 ## Id Date x y leq_mean tags IdTrace ## &lt;chr&gt; &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; ## 1 029d 2021-12-06 22:54:28 -1.56 47.2 42.0 indoor 1 ## 2 045d 2022-01-19 14:33:40 -1.57 47.2 51.1 test,chatting,footsteps,water,animals,vegetation,works 7 ## 3 10fe 2022-01-14 11:06:50 -1.56 47.2 55.3 indoor,chatting 15 ## 4 184d 2022-01-13 16:21:59 -1.54 47.2 69.4 test,chatting,children,footsteps 21 ## 5 284c 2022-03-17 15:10:37 -1.53 47.2 70.3 road 22 ## 6 29f2 2021-12-07 17:33:00 -1.56 47.2 44.1 indoor 25 ## 7 2d6c 2021-12-07 08:53:59 -1.58 47.2 58.7 road,animals 44 ## 8 2dad 2022-03-04 10:06:30 -1.58 47.2 56.3 road 48 ## 9 2f32 2021-12-01 19:21:35 -1.56 47.2 77.9 test,indoor 49 ## 10 32cc 2021-11-27 21:24:14 -1.54 47.2 66.2 indoor,footsteps 59 à partir de la colonne « tags », qui contient pour chaque trace (chaque ligne) un ou plusieurs tags séparés par des virgules : créer une nouvelle colonne « tags » avec un seul tag (par ligne), quitte à dupliquer une trace (une ligne) lorsque cette-dernière a plusieurs tags : tags_table &lt;- tags_table %&gt;% transform(tags = strsplit(as.character(tags),&quot;,&quot;)) %&gt;% unnest(tags) %&gt;% mutate(TagGroup = case_when(tags == &quot;indoor&quot; | tags == &quot;test&quot; ~ &quot;Condition&quot;, tags == &quot;wind&quot; | tags == &quot;rain&quot; ~ &quot;Meteo&quot;, tags == &quot;marine_traffic&quot; | tags == &quot;air_traffic&quot; | tags == &quot;rail&quot; | tags == &quot;road&quot; ~ &quot;Trafic&quot;, TRUE ~ &quot;Ambiance&quot;)) Il y a 57,52 % des traces (635 sur 1104) ayant au moins un tag. Voici les effectifs par tags : summary(as.factor(tags_table$tags)) ## air_traffic alarms animals chatting children footsteps indoor industrial marine_traffic music ## 69 4 153 111 47 96 64 3 3 23 ## rail rain road test vegetation water wind works ## 40 13 403 18 62 12 123 29 Quatre catégories ont été définies : Météo : rain / wind Condition : indoor / test Trafic : road / marine_traffic / air_traffic / rail Ambiance : chatting / footsteps / water / animals / vegetation / works / children / music / alarms / industrial Voici les effectifs par catégorie : ggplot(tags_table, aes(x=TagGroup)) + geom_histogram(stat=&quot;count&quot;) Data_numerique &lt;- tags_table[,c(&quot;x&quot;,&quot;y&quot;,&quot;TagGroup&quot;)] pal &lt;- colorFactor(viridis(7), Data_numerique$TagGroup) leaflet(Data_numerique) %&gt;% addProviderTiles(&quot;CartoDB.Positron&quot;) %&gt;% addCircleMarkers(lng = ~x, lat = ~y, radius = 1.5, color = pal(Data_numerique$TagGroup), stroke=FALSE, fillOpacity = 0.8, popup = ~TagGroup) %&gt;% addLegend(&quot;bottomleft&quot;, pal = pal, values = Data_numerique$TagGroup, na.label = &quot;NA&quot;, title = &quot;Catégories&quot;, #labels = pal2, opacity = .8, ) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
