[["index.html", "Sonorezé Chapitre 1 Présentation", " Sonorezé Tristan Lorino 2022-05-17 Chapitre 1 Présentation Dans RStudio, on installe le package bookdown, puis on créé un nouveau projet avec l’option New Directory et le modèle Book Project Using Bookdown. On appelle WorkinprogReze ce projet ; c’est également le nom du dossier qui est créé en local (et ce sera également le nom du repository GitHub). Ce dossier contient : des fichiers d’extension Rmd (RMarkdown) pour les pages html à générer, dont le fichier index.Rmd qui servira de point de départ pour le site web GitHub ; chaque fichier Rmd contient un et un seul chapitre, lequel est défini par la balise # ; un fichier WorkinprogReze.Rproj relatif au projet RStudio ; un fichier _bookdown.yml qui configure la compilation en entrée ; un fichier _output.yml qui configure la compilation en sortie et le rendu ; un dossier _book qui contient les pages html générées à partir des fichiers rmd. Attention : la compilation par le bouton Knit de RStudio peut faillir dans le rendu du bookdown. Il est alors indispensable de saisir dans la console : bookdown::render_book() Il arrive parfois que la compilation de index.Rmd retourne des messages d’erreur : il peut être utile, dans ce cas de vider le cache de knitr (via le menu déroulant à droite du bouton Knit). Référence Bookdown : https://bookdown.org/yihui/bookdown/ Référence Sonorezé : https://github.com/sonoreze/WorkinprogReze "],["configuration.html", "Chapitre 2 Configuration 2.1 Configuration de knitr 2.2 Déploiement sur GitHub Pages", " Chapitre 2 Configuration 2.1 Configuration de knitr Pour afficher par défaut les morceaux de code R (chunks) : knitr::opts_chunk$set(echo = TRUE) Pour que knitr retrouve tous ses petits dans l’arborescence du dossier WorkinprogReze.Rproj : knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file()) Par défaut on utilise le cache de knitr, ce qui est censé accélérer la compilation : knitr::opts_chunk$set(cache =FALSE) Pour la typo française, on précise que les décimales seront séparées des entiers par une virgule : options(OutDec=&quot;,&quot;) Attention à cette dernière option : elle peut causer des désagréments aux légendes générées avec le package leaflet. Pour les sorties francisées (par exemple les noms des mois) : Sys.setlocale(&quot;LC_CTYPE&quot;,&quot;fr_FR.UTF-8&quot;) 2.2 Déploiement sur GitHub Pages GitHub Pages va puiser les pages html dans un dossier nommé /docs. Aussi commence-t-on par créer un tel dossier dans le dossier WorkinprogReze. Pour déployer le bookdown sur GitHub, on doit transférer de manière automatique les pages html générées par knitr et stockées dans _book, vers le nouveau dossier /docs. Pour ce faire, on ajoute au fichier _bookdown.yml la commande : output_dir: &quot;docs&quot; "],["packages.html", "Chapitre 3 Packages", " Chapitre 3 Packages Le package pacman permet de gérer l’installation préalable, puis le chargement de packages. Voici ceux qui sont utilisés : if (!require(&quot;pacman&quot;)) install.packages(&quot;pacman&quot;) library(pacman) pacman::p_load(here,ggplot2,ggforce,ggthemes,thematic,plotly,scales,tidyr,dplyr,lubridate,stringr,forcats,rgdal,sp,sf, rgeos,geoR,gstat,spacetime,devtools,leaflet,leaflet.extras,jsonlite,mapview,RColorBrewer, viridis,flexdashboard,fontawesome,rprojroot) here : permet une gestion relative de l’arborescence des fichiers ; ggplot2, ggforce, ggthemes, thematic, plotly : gestion des graphiques ; scales : gestion du format des nombres ; tidyr, dplyr : gestion des données ; lubridate : gestion des dates ; forcats : gestion des variables factorielles ; jsonlite, rgdal, sp, sf, geoR, gstat, spacetime : gestion des données spatiales ; leaflet,leaflet.extras, mapview : gestion des représentations spatiales ; RColorBrewer,viridis : gestion des couleurs ; flexdashboard : gestion du tableau de bord html ; fontawesome : accès aux fontes web ; rprojroot : gestion des fichiers de projet R. "],["données.html", "Chapitre 4 Données 4.1 Identifiant de trace 4.2 Longueur des traces", " Chapitre 4 Données 4.1 Identifiant de trace On créé un dossier /R à la racine de WorkinprogReze, dans lequel on stockera les scripts R. On y place dedans le fichier Statistiques.R qui va créer de nombreux tableaux de données à partir des données brutes. On charge les données issues de metabase qui sont contenues dans le fichier noisecapture_data.Rda, puis on compile en entrée deux scripts : Statistiques.R pour la génération de tableaux de données et de statistiques, et Color.R pour la définition d’une palette de couleurs créée par Beate Tomio load(here(&quot;noisecapture_data.Rda&quot;)) source(here(&quot;R&quot;,&quot;Statistiques.R&quot;)) source(here(&quot;R&quot;,&quot;Color.R&quot;)) On va créer, à partir de l’identifiant Id des utilisateurs, les variables suivantes : IdTraceReset : c’est un identifiant de trace par utilisateur, qui s’incrémente dès que le temps passé entre deux enregistrements excède 1 s ; IdGlobal qui concatène Id et IdTraceReset, de manière à avoir un identifiant unique par trace (via stringr::str_c); IdTrace, reformulation de l’identifiant de trace sous forme d’identifiant numérique unique (via dplyr::cur_group_id). On supprime ensuite les traces : sans tag ; dont les coordonnées gps sont manquantes. noisecapture_data &lt;- as.data.frame(noisecapture_data) tags_table_init &lt;- as.data.frame(noisecapture_data[,c(&quot;Id&quot;,&quot;Date&quot;,&quot;x&quot;,&quot;y&quot;,&quot;leq_mean&quot;,&quot;tags&quot;,&quot;accuracy&quot;)]) %&gt;% arrange(Id,Date) %&gt;% filter(tags != &quot;&quot;) %&gt;% filter(x != &quot;NA&quot;) %&gt;% filter(accuracy&lt;20) %&gt;% group_by(Id) %&gt;% arrange(Date) %&gt;% mutate(IdTraceReset=cumsum(c(TRUE, as.integer(diff(as.POSIXct(Date)), units = &quot;secs&quot;) &gt;= 2L))) %&gt;% ungroup() %&gt;% mutate(IdGlobal=str_c(Id,IdTraceReset)) %&gt;% arrange(IdGlobal) %&gt;% group_by(Id) %&gt;% arrange(IdTraceReset) %&gt;% group_by(IdGlobal) %&gt;% mutate(IdTrace=cur_group_id()) %&gt;% ungroup() %&gt;% select(-c(accuracy,IdGlobal,IdTraceReset)) 4.2 Longueur des traces Afin que le tag ait un sens, on va supprimer les traces dont la longueur excède 500 m. Pour ce faire, on calcule les distances entre les points géolocalisés consécutifs pris deux à deux (pour chaque trace), puis on calcule la somme des distances par trace, et enfin on ne sélectionne que les traces dont la distance totale est inférieure à 500 m : tags_table &lt;- tags_table_init %&gt;% st_as_sf(coords = c(&quot;x&quot;,&quot;y&quot;),remove = F) %&gt;% st_set_crs(4326) %&gt;% group_by(IdTrace) %&gt;% mutate( lead = geometry[row_number() + 1], Dist = st_distance(geometry, lead, by_element = T), ) %&gt;% mutate(DistTot = sum(as.numeric(Dist),na.rm=TRUE)) %&gt;% select(-c(lead)) %&gt;% filter(DistTot&lt;500) "],["tags.html", "Chapitre 5 Tags", " Chapitre 5 Tags Voici les données : tags_table[1:10,] ## Simple feature collection with 10 features and 9 fields ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: -1.561305 ymin: 47.18937 xmax: -1.551299 ymax: 47.19119 ## Geodetic CRS: WGS 84 ## # A tibble: 10 × 10 ## # Groups: IdTrace [2] ## Id Date x y leq_mean tags IdTrace geometry Dist DistTot ## &lt;chr&gt; &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;POINT [°]&gt; [m] &lt;dbl&gt; ## 1 029d 2021-12-06 22:54:28 -1.56 47.2 42.0 indoor 1 (-1.561303 47.19119) 0.427 0.851 ## 2 029d 2021-12-06 22:54:29 -1.56 47.2 41.2 indoor 1 (-1.561305 47.19118) 0.359 0.851 ## 3 029d 2021-12-06 22:54:30 -1.56 47.2 40.8 indoor 1 (-1.561305 47.19118) 0.0654 0.851 ## 4 029d 2021-12-06 22:54:31 -1.56 47.2 45.7 indoor 1 (-1.561305 47.19118) NA 0.851 ## 5 03ad 2022-01-13 08:24:31 -1.55 47.2 63.9 rail 13 (-1.551299 47.18947) 16.3 25.5 ## 6 03ad 2022-01-13 08:24:32 -1.55 47.2 63.1 rail 13 (-1.551501 47.18942) 7.78 25.5 ## 7 03ad 2022-01-13 08:24:33 -1.55 47.2 63.8 rail 13 (-1.551582 47.18937) 1.42 25.5 ## 8 03ad 2022-01-13 08:24:34 -1.55 47.2 63.7 rail 13 (-1.551567 47.18938) 0 25.5 ## 9 03ad 2022-01-13 08:24:35 -1.55 47.2 61.4 rail 13 (-1.551567 47.18938) 0 25.5 ## 10 03ad 2022-01-13 08:24:36 -1.55 47.2 61.2 rail 13 (-1.551567 47.18938) 0 25.5 La procédure de traitement des tags consiste à : ne garder qu’un enregistrement par trace ; à partir de la colonne tags, qui contient pour chaque trace (chaque ligne) un ou plusieurs tags séparés par des virgules : créer une nouvelle colonne tags avec un seul tag (par ligne), quitte à dupliquer une trace (une ligne) lorsque cette-dernière a plusieurs tags : On créé une autre table de données avec les tags de groupe : tags_table_taggroup &lt;- tags_table %&gt;% distinct(IdTrace, .keep_all = TRUE) %&gt;% transform(tags = strsplit(as.character(tags),&quot;,&quot;)) %&gt;% unnest(tags) %&gt;% mutate(TagGroup = case_when(tags == &quot;indoor&quot; | tags == &quot;test&quot; ~ &quot;Condition&quot;, tags == &quot;wind&quot; | tags == &quot;rain&quot; ~ &quot;Meteo&quot;, tags == &quot;marine_traffic&quot; | tags == &quot;air_traffic&quot; | tags == &quot;rail&quot; | tags == &quot;road&quot; ~ &quot;Trafic&quot;, TRUE ~ &quot;Ambiance&quot;)) On passe de 766 traces initialement (toutes longeuurs confondues) à 729, soit une conservation de 95.17 % des traces. Voici les effectifs par tags : summary(as.factor(tags_table_taggroup$tags)) ## air_traffic alarms animals chatting children footsteps indoor industrial marine_traffic music rail ## 104 5 164 110 49 117 72 5 3 27 44 ## rain road test vegetation water wind works ## 16 470 16 63 9 129 30 Quatre catégories ont été définies : Météo : rain / wind Condition : indoor / test Trafic : road / marine_traffic / air_traffic / rail Ambiance : chatting / footsteps / water / animals / vegetation / works / children / music / alarms / industrial Voici les effectifs par catégorie : ggplot(tags_table_taggroup, aes(x=TagGroup)) + geom_histogram(stat=&quot;count&quot;) Voici une représentation spatiale des catégories de tags : Data_numerique &lt;- tags_table_taggroup[,c(&quot;x&quot;,&quot;y&quot;,&quot;TagGroup&quot;)] pal &lt;- colorFactor(viridis(7), Data_numerique$TagGroup) leaflet(Data_numerique) %&gt;% addProviderTiles(&quot;CartoDB.Positron&quot;) %&gt;% addCircleMarkers(lng = ~x, lat = ~y, radius = 1.5, color = pal(Data_numerique$TagGroup), stroke=FALSE, fillOpacity = 0.8, popup = ~TagGroup) %&gt;% addLegend(&quot;bottomleft&quot;, pal = pal, values = Data_numerique$TagGroup, na.label = &quot;NA&quot;, title = &quot;Catégories&quot;, #labels = pal2, opacity = .8, ) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
